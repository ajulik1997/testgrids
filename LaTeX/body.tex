\section{Motivation}

CASTEP is a leading academic and commercial software package which uses density functional theory to calculate the electronic properties of materials from first principles. One of CASTEP's unique selling points is its ease-of-use for scientists who are not experts in electronic structure theory or numerical methods, that is mainly achieved by intelligent automatic selection of default values for many of the convergence parameters as well as allowing for the selection of precision of most aspects of a calculation from a short list of discrete levels (from COARSE to EXTREME).

Despite this, there is no such intelligent selection available for setting the density of the fine FFT grid used for the on-the-fly (OTF) generation of pseudopotentials, and CASTEP currently defaults to a fine grid size identical to the standard grid used for calculating the Kohn-Sham orbitals. However, this default setting is inadequate for the default OTF pseudopotentials describing a majority of the elements in the periodic table, which require a much finer grid to represent an atom's pseudized core and ultrasoft augmentation charge densities. Additionally, the fine grid density is one of the most difficult parameters to test for convergence due to its strong correlation with plane-wave cutoff, and as a result, many CASTEP calculations are either under-converged (compromising accuracy) or over-converged (wasting CPU time).

This project aimed to remedy this shortcoming by developing and testing scripts for determining a set of FINE\_GMAX values corresponding to FINE\_GRID\_SIZE precision levels from COARSE to EXTREME for a number of supported elements. This database of FINE\_GMAX values would be generated for the C19, QC5 and NCP19 pseudopotential libraries and will be implemented into CASTEP using a lookup table.

The document is split into two section representing the two major stages of the project. Any code that has been developed is described in detail, including a discussion of any prerequisites, troubleshooting, customisation and frequent use-cases.

\section{Section 1: testgrids.py}

\code{testgrids.py} is a Python 3 script for investigating the behaviour of CASTEP simulations with a varying FINE\_GRID\_SIZE parameter for all supported elements. The script takes care of generating test data, submitting it to the SLURM Workload Manager (SLURM), monitoring the SLURM queue, extracting and plotting the relevant data, as well as saving all relevant data to both machine- and human-readable files.

When running the script with no arguments (\code{python testgrids.py}), the default values for all possible arguments are assumed. The execution begins by checking if a temporary data folder from a previous run with the same name exists; this is \code{tmp} by default, but can be changed with the \code{--name} argument. If this folder exists, it is emptied to prepare it for the data that will be generated during this run. Additionally, a script that deletes any unused semaphores is executed prior to any work being submitted to SLURM.

Next, the job data necessary for this run is generated. By default, a total of 4473 folders is created: 9 different fine grid size values between 2.0 and 6.0, each with 7 different volumes between 94\% and 106\% (as specified by the $\Delta$-project \cite{delta}), for all 71 supported elements that will be simulated. Each folder, named with the corresponding element symbol and a numerical suffix, will contain one \code{.cell} file that details the geometry and parameters of the cell being simulated, and one \code{.param} file that will contain all of the control parameters required to run a CASTEP job. The parent data folder will also contains one \code{.job} file per element, which contains the necessary information for SLURM to treat all jobs corresponding to that element as a single job array and submit it to the queue.

Following the preparation of job data, the script then submits each element as a job array to the SLURM queue, 10 elements at a time by default as to not pollute the queue with too many jobs. At this stage, the progress of job execution is monitored by polling the SLURM queue (every second by default) and reported to the user.

After the completion of all job arrays, the useful data generated by CASTEP needs to be collected and analysed; the reported cell volume and stress, final converged energy, number of iterations that were required for its convergence, total simulation time, fine grid dimensions and real lattice vectors are collected from the new \code{.castep} files and stored in an array. Any warnings or errors during this stage are also reported. The collected volumes and energies are sent to a Birch-Murnaghan equation-of-state (EOS) fitting function that returns the reference volume, bulk modulus and its derivative w.r.t. pressure. On occasions that a good fit cannot be found for any group of volumes, the user is warned and any data for that group is discarded. For all successful fits, $\Delta$-values \cite{delta} are calculated from the EOS data by reference to the EOS data for the largest tested fine grid size of that element. At the end of this stage of execution, all collected values are saved in a human-readable file \code{tmp.table.txt}, all $\Delta$-values are summarised in a machine-readable file \code{tmp.deltas.txt} and the array of collected values is also pickled for further use in \code{tmp.pickle}.

Finally, a 2 by 2 grid of plots is drawn for every element and either shown on screen or saved to a \code{.png} file. The plots show the coarse and fine view of the relationship between the calculated $\Delta$-values and the \code{FINE\_GRID\_SIZE} or corresponding \code{FINE\_GMAX} parameters. When this is completed, the semaphore cleaning script that was used at the beginning of the execution of this script is sent to SLURM again in order to clean up after any potential failures or crashes. If requested (no by default), the \code{tmp} data directory is also deleted, as all useful data has already been saved elsewhere.

\begin{figure}[h]
    \centering
    \includegraphics{testgrids_default.png}
    \caption{Summary of all the customisable parameters and their values during a default run. A summary card like this is printed at the beginning of every run, and should be especially useful if the execution output is being logged.}
    \label{fig:testgrids_default}
\end{figure}

\subsection{Installation and Requirements}

The \code{testgrids.py} script does not require any installation or compilation, however, there are a number of mandatory (and optional) packages that are required for the script to work. The list below summarised these requirements, with all quoted version numbers representing the versions that were used during the development and testing of the code. The usage of ``\code{X.X} or higher" here assumes that no changes to the packages will be introduced in the future that will break compatibility with the current requirements. Similarly, it is likely that any package with the same major version will also work, therefore the version numbers in following list can be interpreted as a guidance more than an absolute requirement:

\begin{itemize}
    \item $[$Mandatory$]$ \code{Environment Modules 3.2.10} or higher \cite{modules}
    \item $[$Mandatory$]$ \code{CASTEP 18.1.2} or higher \cite{castep}
    \item $[$Mandatory$]$ \code{Python 3.6.4} or higher \cite{python}
    \item $[$Mandatory$]$ \code{NumPy 1.14.0} or higher \cite{numpy}
    \item $[$Mandatory$]$ \code{Matplotlib 2.1.2} or higher \cite{matplotlib}
    \item $[$Mandatory$]$ any of the following Matplotlib non-interactive backends: \code{agg}, \code{cairo}, \code{gdk}, \code{pdf}, \code{pgf}, \code{ps}, \code{svg}
    \item $[$Optional$]$ any of the following Matplotlib interactive backends: \code{GTK}, \code{GTKAgg}, \code{GTKCairo}, \code{MacOSX}, \code{Qt4Agg}, \code{Qt5Agg}, \code{TkAgg}, \code{WX}, \code{WXAgg}, \code{GTK3Cairo}, \code{GTK3Agg}, \code{WebAgg}, \code{nbAgg}
\end{itemize}

It should be noted that with proper usage of the Environment Modules package, some of the requirements will have to be loaded using the \code{module load} statement before they can be used. On the system where the script was tested, only Python and Matplotlib needed to be loaded, as the script itself takes care of loading CASTEP, and NumPy as well as the required Matplotlib backends were available with Python. If Matplotlib is available as a module separate from Python, as was the case with this system, loading the Matplotlib module will also load the required Python module as a dependency, and therefore the loading of all required modules can be accomplished with a single statement. It should be also be noted that, if the user encounters a syntax error during the execution of the script, this means that Python 2 has been loaded instead of the required Python 3.

Below is also a directory tree showing all the auxiliary files that are included with \code{testgrids.py} along with a short description of their purpose. In order for the script to be able to access these files, its working directory has to be set to its root folder. Files and directories marked with \code{*} are obtained from the $\Delta$ calculation package directly (without any modifications) \cite{delta}, while those marked with \code{**} are also obtained from the same package but have been modified for use with this script.

\hspace{10mm}

\begin{forest}
  for tree={
    font=\ttfamily,
    grow'=0,
    child anchor=west,
    parent anchor=south,
    anchor=west,
    calign=first,
    edge path={
      \noexpand\path [draw, \forestoption{edge}]
      (!u.south west) +(7.5pt,0) |- node[fill,inner sep=1.25pt] {} (.child anchor)\forestoption{edge label};
    },
    before typesetting nodes={
      if n=1
        {insert before={[,phantom]}}
        {}
    },
    fit=band,
    before computing xy={l=15pt},
  }
[\code{testgrids/} \hspace{13.8mm} \small{$\textrm{(root directory)}$}
  [\code{* CIFs/} \hspace{14mm} \small{$\textrm{(directory with CIF files of 71 elemental crystals in their ground state structure)}$}
    [\code{* Ag.cif}]
    [...]
    [\code{* Zr.cif}]
  ]
  [\code{* primCIFs/} \hspace{6.6mm} \small{$\textrm{(directory with CIF files of 71 elemental crystals in a primitive unit cell)}$}
    [\code{* Ag.cif}]
    [...]
    [\code{* Zr.cif}]
  ]
  [\code{* calcDelta.py} \hspace{1mm} \small{$\textrm{(Python script that calculates the } \Delta\textrm{-factor between two data sets)}$}
  ]
  [\code{** eosfit.py} \hspace{4.6mm} \small{$\textrm{(Python script that fits a single set of E(V) data to the Birch-Murnaghan EOS)}$}
  ]
  [\code{ipcclean} \hspace{12mm} \small{$\textrm{(shell script that cleans up unused semaphores from previous SLRUM jobs)}$}
  ]
  [\code{template.job} \hspace{4.6mm} \small{$\textrm{(template shell script for submitting job arrays to SLURM)}$}
  ]
  [\code{testgrids.py} \hspace{4.6mm} \small{$\textrm{(main Python script)}$}
  ]
]
\end{forest}

\subsection{Usage examples}

This section provides examples of common use case scenarios of \code{testgrids.py}, ranging from the most basic (that require only passing a few arguments) to fairly advanced (that may require some editing of code). A full list of all supported arguments, their accepted values and any other relevant information about them is given in a table at the end of this section. Depending on the argument, some text and values have been obtained from the CASTEP \cite{castep_doc} or SLURM \cite{slurm_doc} documentation pages.

\vspace{0.75cm} \noindent
\begin{tabular}{ m{2.5cm} m{13.2cm} }
    \hline \hline
    \textbf{QUESTION}: & I want to do a default run and save the results with the name ``default". I don't care about any temporary files, these can be deleted. \\
    \hline
    \textbf{SOLUTION}: & \code{python testgrids.py --name default --clean true} \\  
    \hline
    \textbf{CONCISE}: & \code{python testgrids.py -na default -cl y} \\   
    \hline
    \textbf{NOTE:} & It is always a good idea to give your run a name, as this is the name that will also be given to all relevant files and plots. \\
    \hline \hline
\end{tabular} 

\vspace{0.75cm} \noindent
\begin{tabular}{ m{2.5cm} m{13.2cm} }
    \hline \hline 
    \textbf{QUESTION}: & I want to do a default run but only for silicon. I also want to open the generated plot in interactive view. \\
    \hline 
    \textbf{SOLUTION}: & \code{python testgrids.py --element Si --save false} \\  
    \hline 
    \textbf{CONCISE}: & \code{python testgrids.py -el Si -sa n} \\
    \hline 
    \textbf{NOTE:} & Using \code{--save false} is not recommended for when a run involves more than a few elements. Interactive plotting windows are opened sequentially (next window opens after the previous one is closed). For all 71 elements, this would represent 71 separate plots. \\
    \hline \hline 
\end{tabular}

\vspace{0.75cm} \noindent
\begin{tabular}{ m{2.5cm} m{13.2cm} }
    \hline \hline 
    \textbf{QUESTION}: & I want to do a default run but over a higher range (1.5 to 6.5) and with a larger density (0.1) of \code{FINE\_GRID\_SIZE} values. \\
    \hline 
    \textbf{SOLUTION}: & \code{python testgrids.py --fine\_grid\_min 1.5 --fine\_grid\_max 6.5 ...} \code{... --fine\_grid\_step 51 --name long\_run} \\
    \hline 
    \textbf{CONCISE}: & \code{python testgrids.py -f0 1.5 -f1 6.5 -fs 51 -na long\_run} \\
    \hline 
    \textbf{NOTE:} & A run with 51 \code{FINE\_GRID\_SIZE} steps and the default number of elements will require $51*7*71=25,347$ total jobs, which will take a significant time to complete. When starting a long run, it is recommended to verify that the run behaves and gives results as expected, usually by doing a preliminary run with a single element or a smaller number of steps. \\
    \hline \hline 
\end{tabular} 

\vspace{0.75cm} \noindent
\begin{tabular}{ m{2.5cm} m{13.2cm} }
    \hline \hline 
    \textbf{QUESTION}: & I have a lot of nodes with 64 cores available to me under the reservation ``El\_Psy\_Kongroo". As my run involves large jobs, I want each job to run on 2 nodes. \\
    \hline 
    \textbf{SOLUTION}: & \code{python testgrids.py --reserve El\_Psy\_Kongroo --tasks 64 --nodes 2 ...} \code{... --queue 100} \\
    \hline 
    \textbf{CONCISE}: & \code{python testgrids.py -r El\_Psy\_Kongroo -t 64 -no 2 -q 100} \\
    \hline 
    \textbf{NOTE:} & The semaphore cleanup script is not available when using \code{--reserve}, so any necessary cleanup needs to be done before starting the run. When using \code{--tasks} and \code{--nodes}, it is important to know the number of cores available per node, as well as the performance implications of running a job across many cores and nodes. Setting a large value for \code{--queue} will submit an equally large number of job arrays to the SLURM queue (or all jobs waiting to be submitted, whichever is smaller), therefore it is important to be mindful of this if you aren't using reserved nodes. \\
    \hline \hline 
\end{tabular}

\vspace{0.75cm} \noindent
\begin{tabular}{ m{2.5cm} m{13.2cm} }
    \hline \hline 
    \textbf{QUESTION}: & I am testing the behaviour of a new set of values for some parameters, and would like the script to be as verbose as possible. As I am logging the output, I do need frequent infromation about job progress in the SLURM queue. \\
    \hline 
    \textbf{SOLUTION}: & \code{python testgrids.py --name test --debug 1 --poll\_wait 60 >> test.log} \\
    \hline 
    \textbf{CONCISE}: & \code{python testgrids.py -na test -d 1 -po 60 >> test.log} \\
    \hline 
    \textbf{NOTE:} & Using \code{--debug 1} will enable debugging mode that, at level 1, only enables verbose output. At higher levels, debug mode is used to control the flow of code (this is discussed further in the next section) and should not be used unless you understand the implications of the value you have chosen. Setting \code{--poll\_wait} to higher values increases the time between successive checks of the SLURM queue, that in turn decreases the amount of repetitive output. However, jobs that are pending to be submitted to the queue can only be submitted after the queue reports that it is empty, therefore very high values of \code{--poll\_wait} are likely to waste time by leaving the SLURM queue empty for longer.\\
    \hline \hline 
\end{tabular}

\vspace{0.75cm} \noindent
\begin{tabular}{ m{2.5cm} m{13.2cm} }
    \hline \hline 
    \textbf{QUESTION}: & I have completed a run previously and have the relevant \code{.pickle} file. I would like to open these plots in interactive view again. \\
    \hline 
    \textbf{SOLUTION}: & \code{python testgrids.py --load old\_run.pickle --save false} \\
    \hline 
    \textbf{CONCISE}: & \code{python testgrids.py -l old\_run.pickle -sa n} \\
    \hline 
    \textbf{NOTE:} & When using \code{--load}, the built-in argument parser will ignore all arguments besides \code{--save}. This way, it is possible to either revisit old data using interactive plots, or re-plot old data and save the figures when the previous ones are no longer available or were never plotted. This is especially useful for runs with a reused \code{--name} argument that did not save any new figures (\code{testgrids.py} will not overwrite an existing directory in \code{./figs}). Similar functionality can be achieved by repeating your run with identical arguments and adding \code{--debug 4}, however, the former method is preferred. \\
    \hline \hline 
\end{tabular}

\vspace{0.75cm} \noindent
\begin{tabular}{ m{2.5cm} m{13.2cm} }
    \hline \hline 
    \textbf{QUESTION}: & I would like to do a run involving the calculation of a stress tensor on elemental crystals in their primitive unit cell. \\
    \hline 
    \textbf{SOLUTION}: & \code{python testgrids.py --primitive true --stress true} \\
    \hline 
    \textbf{CONCISE}: & \code{python testgrids.py -pr y -st y} \\
    \hline 
    \textbf{NOTE:} & Choosing to run calculations on elemental crystals in their primitive unit cell instead of the default ground state structure will allow for faster calculations, however, the results will no longer be interpretable in the same way as those quoted on the $\Delta$-project website. Enabling calculations of the stress tensor will instead increase the total calculation time. The pressure (in GPa) will be visible in the \code{name.table.txt} file, however, this setting should have no effect on the generated plots. \\
    \hline \hline 
\end{tabular}

\vspace{0.75cm} \noindent
\begin{tabular}{ m{2.5cm} m{13.2cm} }
    \hline \hline 
    \textbf{QUESTION}: & I would like to tweak some arguments relating to the density mixing procedure. \\
    \hline 
    \textbf{SOLUTION}: & \code{python testgrids.py --mix\_scheme broyden --mix\_charge\_amp 0.8 ...} \code{... --mix\_spin\_amp 1.75} \\
    \hline 
    \textbf{CONCISE}: & \code{python testgrids.py -mi broyden -mc 0.8 -ms 1.75} \\
    \hline 
    \textbf{NOTE:} & When experiencing SCF convergence failures, it is often helpful to switch \code{--mix\_scheme} between Pulay and Broyden, as well as decreasing the mixing amplitude for the charge and spin density arguments. \\
    \hline \hline 
\end{tabular}

\vspace{0.75cm} \noindent
\begin{tabular}{ m{2.5cm} m{13.2cm} }
    \hline \hline 
    \textbf{QUESTION}: & I would like to do a run involving a metal or finite-temperature insulator. I would also like to also increase the precision of this run in all available aspects. \\
    \hline 
    \textbf{SOLUTION}: & \code{python testgrids.py --extra\_bands 120 --basis\_prec precise ...} \code{... --elec\_enrg\_tol 1e-8 --grid 2.5 --kpoint\_spacing 0.15 ...} \code{... --max\_scf\_cycles 200} \\
    \hline 
    \textbf{CONCISE}: & \code{python testgrids.py -ba 120 -bp precise -ee 1e-8 -g 2.5 -k 0.15 -sc 200} \\
    \hline 
    \textbf{NOTE:} & When dealing with metals or finite-temperature insulators, it can be useful to increase the number of available bands using \code{--extra\_bands}. Although the default value of \code{--extra\_bands 100} should be enough for most scenarios, no significant performance losses were measured with using higher values. It should be noted that the above combination of parameters does not necessarily correspond to a real-life scenario, and is instead used for demonstration of the available arguments. Good understanding of the advantages and drawbacks of the above parameters and their combinations is essential in obtaining meaningful results from a run. Setting \code{--basis\_prec} to a higher level increases the precision of convergence of atomic energies with respect to the plane wave cutoff energy. Decreasing \code{--elec\_enrg\_tol} decreases the tolerance for accepting convergence of the total energy in an electronic minimisation. Increasing \code{--grid} increases the size of the standard grid, relative to the diameter of the cutoff sphere (it is important to be aware that changes to this argument also impacts \code{FINE\_GRID\_SIZE}, which is defined relative to \code{GRID\_SIZE}). Choosing a smaller \code{--kpoint\_spacing} increases the k-point density in reciprocal space, in turn increasing the smoothness of the ground state energy well. Increasing \code{--max\_scf\_cycles} increases the maximum number of SCF cycles performed in an electronic minimisation, therefore reducing the likelihood of failed convergence (although frequent SCF convergence failures often point to a different problem). A well thought-out combination of some or all of these arguments backed by a number of preliminary runs is often required. It should also be obvious that tweaking most of these parameters will have a noticeable impact on the performance of a run. \\
    \hline \hline 
\end{tabular}

\vspace{0.75cm} \noindent
\begin{tabular}{ m{2.5cm} m{13.2cm} }
    \hline \hline 
    \textbf{QUESTION}: & I would like to use the LDA exchange-correlation functional for this run. Since the LDA description tends to overbind atoms and underestimate cell volume, I would like to apply a +3\% cell volume correction before $\Delta$ calculations take place. \\
    \hline 
    \textbf{SOLUTION}: & \code{python testgrids.py --xc\_functional LDA --volume\_scale 1.03} \\
    \hline 
    \textbf{CONCISE}: & \code{python testgrids.py -x LDA -v 1.03} \\
    \hline 
    \textbf{NOTE:} & Cell volume scaling is applied before any $\Delta$-project relevant calculations take place; the \code{--volume\_scale} argument can therefore be useful if you encounter a lot of fitting errors from the Birch-Murnaghan EOS fitting function. The \code{--xc\_functional} argument currently supports a large number of functionals, including all the functionals documented in CASTEP 18.1. If you know that the CASTEP version you are using includes support for a functional that is not supported by \code{testgrids.py}, you can add it yourself: open \code{testgrids.py} in your preferred editor, scroll down to the \code{parse\_args(...)} function, look for a statement with \code{args.xc\_functional} and a list of functionals, and add your functional to the list. If a functional that is not currently supported becomes popular, I will endeavour to update the list. \\
    \hline \hline 
\end{tabular}

\vspace{0.75cm} \noindent
\begin{tabular}{ m{2.5cm} m{13.2cm} }
    \hline \hline 
    \textbf{QUESTION}: & I would like to use a different version of CASTEP for this run, and because I'm doing some testing, I would like to increase the verbosity of the generated \code{.castep} files. \\
    \hline 
    \textbf{SOLUTION}: & \code{python testgrids.py --castep CASTEP/19.11 --ilevel 3} \\
    \hline 
    \textbf{CONCISE}: & \code{python testgrids.py -ca CASTEP/19.11 -i 3} \\
    \hline 
    \textbf{NOTE:} & Although CASTEP's \code{IPRINT} argument accepts values of 1, 2 and 3, \code{--ilevel} does not support level 1 as this option does not produce a verbose enough output in the \code{.castep} files for scraping the required information. Level 2 is the default, and it can be increased up to level 3 for additional verbosity. If a different CASTEP version is to be used for all runs, it is fairly simple to edit the default CASTEP module used by \code{testgrids.py} to avoid having to use the \code{--castep} argument with every run: open \code{testgrids.py} in your preferred editor, scroll down to the \code{parse\_args(...)} function, look for a statement with \code{args.castep = "CASTEP/19.1.1-foss-2018a"} and edit the string to match the name of your CASTEP module. \\
    \hline \hline 
\end{tabular}

\vspace{0.75cm} \noindent
\begin{tabular}{ m{2.5cm} m{13.2cm} }
    \hline \hline 
    \textbf{QUESTION}: & I have a directory containing \code{.cif} files which I would like to use for my run. \\
    \hline 
    \textbf{SOLUTION}: & \code{python testgrids.py --cif\_dir /path/to/dir}\\
    \hline 
    \textbf{CONCISE}: & \code{python testgrids.py -cf /path/to/dir} \\
    \hline 
    \textbf{NOTE:} & When \code{--cif\_dir} is specified, the \code{--primitive} argument is ignored. This argument is especially useful for doing a run involving a subset of elements from \code{.cif} files already provided with \code{testgrids.py}: simply copy the elements of your choice into a new directory, and supply the path to that directory (either relative or absolute) to the \code{--cif\_dir} argument. When using custom \code{.cif} files, it is essential that the files contain enough information for CASTEP's \code{cif2cell} script to generate a \code{.cell} file containing \code{BLOCK LATTICE\_CART}, \code{BLOCK POSITIONS\_FRAC}, \code{BLOCK SPECIES\_POT} and \code{BLOCK SYMMETRY\_OPS}. \\
    \hline \hline 
\end{tabular}

\vspace{0.75cm} \noindent
\begin{tabular}{ m{2.5cm} m{13.2cm} }
    \hline \hline 
    \textbf{QUESTION}: & I would like to use specific pseudopotential library for my run. \\
    \hline 
    \textbf{SOLUTION}: & \code{python testgrids.py --pseudo\_pot NCP19}\\
    \hline 
    \textbf{CONCISE}: & \code{python testgrids.py -ps NCP19} \\
    \hline 
    \textbf{NOTE:} & The list of possible pseudopotential libraries that can be officially used with \code{testgrids.py} is limited to only C19, QC5 and NCP19. Although this script was not intended for use with other libraries that are available with CASTEP, adding your own pseudopotential to the list of supported ones should not cause any issues: open \code{testgrids.py} in your preferred editor, scroll down to the \code{parse\_args(...)} function, look for a statement with \code{args.pseudo\_pot} and a list of pseudopotential libraries, and add your library to the list. Furthermore, the list of libraries is not necessarily limited to libraries: you may add \code{.otfglib}, \code{.usp}, \code{.uspcc}, \code{.uspso}, \code{.recpot}, \code{.upf}, \code{.dat} or  \code{.data} files (with their file extension), as well as a valid OTFG pseudopotential string to the list. If your usage of \code{testgrids.py} will involve a number unsupported pseudopotentials, you may simply comment out the \code{if} block containing \code{args.pseudo\_pot} to suppress the check carried out by the argument parser. \\
    \hline \hline 
\end{tabular}

\clearpage

\begin{table}[!h]
\centering
\begin{tabularx}{1\linewidth}{|c|c|c|c|>{\hsize=.6\hsize\linewidth=\hsize}Y|>{\hsize=1.4\hsize\linewidth=\hsize}Y|}
\hline
\textbf{Argument} & \textbf{Abbr.} & \textbf{Type} & \textbf{Default} & \textbf{Accepted values} & \textbf{Notes} \\ \hline

\code{--extra\_bands} & \code{-ba} & \code{float} & \code{100.0} & any $\geq 0$ & Controls the percentage of extra bands in addition to the number of occupied bands (necessary for metals or finite temperature insulators). Corresponds to the CASTEP \code{.param} file keyword \code{PERC\_EXTRA\_BANDS}. \\ \hline

\code{--basis\_prec} & \code{-bp} & \code{str} & \code{"FINE"} & any one of \code{COARSE}, \code{MEDIUM}, \code{FINE}, \code{PRECISE} or \code{EXTREME} & Specifies the precision of the basis set by choosing the level of convergence of atomic energies with respect to the plane wave cutoff energy. Corresponds to the CASTEP \code{.param} file keyword \code{BASIS\_PRECISION}. \\ \hline

\code{--castep} & \code{-ca} & \code{str} & \code{""} & any string corresponding to a CASTEP module that can be loaded & Specifies the CASTEP module that will be used during the exacution of the script. Validated by attempting to load the specified module in a clean environment. If no value provided, argument defaults to \code{CASTEP/19.1.1-foss-2018a} \\ \hline

\code{--clean} & \code{-cl} & \code{bool} & \code{False} & any string than can be interpreted as a boolean & Specifies whether the temporary data folder should be deleted at the end of the execution of the script. \\ \hline

\code{--cif\_dir} & \code{-cf} & \code{str} & \code{""} & any string corresponding to a valid path to a directory & Specifies the directory containing the \code{.cif} files to be used. Validated by checking the existence of the directory. If no value provided, argument defaults to either \code{./CIFs} or \code{./primCIFs} depending on the value of the \code{--primitive} argument\\ \hline

\code{--debug} & \code{-d} & \code{int} & \code{0} & any $\geq 0$ & Specifies the debug level, increasing script verbosity and controlling code flow.\\ \hline

\code{--elec\_enrg\_tol} & \code{-ee} & \code{float} & \code{1e-5} & any $> 0$ & Controls the tolerance for accepting convergence of the total energy in an electronic minimisation. Corresponds to the CASTEP \code{.param} file keyword \code{ELEC\_ENERGY\_TOL}. \\ \hline

\code{--element} & \code{-el} & \code{str} & \code{""} & any string corresponding to a symbol of an element present in the CIFs directory & Specifies which single element to simulate, validated by verifying the existence of a corresponding .cif file in the directory specified by \code{--cif\_dir}. If no value provided, argument defaults to all elements in the CIFs folder \\ \hline

\code{--fine\_grid\_min} & \code{-f0} & \code{float} & \code{2.0} & $1 \leq$ any $\leq$ \code{-f1} & Specifies the lowest value of the CASTEP \code{.param} file keyword \code{FINE\_GRID\_SCALE}. \\ \hline

\code{--fine\_grid\_max} & \code{-f1} & \code{float} & \code{6.0} & any $\geq$ \code{-f0} &  Specifies the highest value of the CASTEP \code{.param} file keyword \code{FINE\_GRID\_SCALE}. \\ \hline

\code{--fine\_grid\_step} & \code{-fs} & \code{int} & \code{9} & any $\geq 2$ & Specifies the number of samples between \code{--fine\_grid\_min} and \code{--fine\_grid\_max} (inclusive). \\ \hline

\code{--grid} & \code{-g} & \code{float} & \code{1.75} & any $\geq 1$ & Specifies the fixed value of the CASTEP \code{.param} file keyword \code{GRID\_SCALE}. \\ \hline

\code{--ilevel} & \code{-i} & \code{int} & \code{2} & 2 or 3 & Specifies the level of verbosity of \code{.castep} files. Corresponds to the CASTEP \code{.param} file keyword \code{IPRINT}. \\ \hline

\code{--kpoint\_spacing} & \code{-k} & \code{float} & \code{0.2} & any $> 0$ & Specifies the k-point density of a Monkhorst-Pack grid (units of inverse length). Corresponds to the CASTEP \code{.cell} file keyword \code{KPOINT\_MP\_SPACING}. \\ \hline

\code{--load} & \code{-l} & \code{str} & \code{""} & Any string corresponding to a valid path to a file & Specifies the path to a \code{.pickle} file that will be loaded instead of running any simulations. Validated by verifying the existence of the specified file. \\ \hline

\end{tabularx}
\caption{Summary of optional arguments that can be passed to the \code{testgrids.py} (Part 1: [a-l])}
\label{tab:arguments1}
\end{table}

\clearpage

\begin{table}[!h]
\centering
\begin{tabularx}{1\linewidth}{|c|c|c|c|>{\hsize=.6\hsize\linewidth=\hsize}Y|>{\hsize=1.4\hsize\linewidth=\hsize}Y|}
\hline
\textbf{Argument} & \textbf{Abbr.} & \textbf{Type} & \textbf{Default} & \textbf{Accepted values} & \textbf{Notes} \\ \hline

\code{--mix\_charge\_amp} & \code{-mc} & \code{float} & \code{0.5} & any $> 0$ & Determines the mixing amplitude for the charge density in the density mixing procedure. Corresponds to the CASTEP \code{.param} file keyword \code{MIX\_CHARGE\_AMP}. \\ \hline

\code{--mix\_scheme} & \code{-mi} & \code{str} & \code{"PULAY"} & any one of \code{BROYDEN}, \code{KERKER}, \code{LINEAR} or \code{PULAY} & Determines which mixing scheme will be used in the density mixing procedure. Corresponds to the CASTEP \code{.param} file keyword \code{MIXING\_SCHEME}. \\ \hline

\code{--mix\_spin\_amp} & \code{-ms} & \code{float} & \code{0.5} & any $> 0$ & Determines the mixing amplitude for the spin density in the density mixing procedure. Corresponds to the CASTEP \code{.param} file keyword \code{MIX\_SPIN\_AMP}. \\ \hline

\code{--name} & \code{-na} & \code{str} & \code{"tmp"} & any string & Specifies the name of this run, corresponding to the filenames of the generated files and the temporary simulation data directory. \\ \hline

\code{--nodes} & \code{-no} & \code{int} & \code{1} & any $\geq 1$ & Corresponds to the number of SLURM nodes that will be assigned to each job array. \\ \hline

\code{--poll\_wait} & \code{-po} & \code{int} & \code{1} & any $\geq 1$ & Specifies the time in seconds to wait between polling the SLURM \code{squeue} (used for tracking job progress). Higher values may waste time by not scheduling new jobs in time, while lower values may slow down the machine. \\ \hline

\code{--primitive} & \code{-pr} & \code{bool} & \code{False} & any string that can be interpreted as a boolean & Specifies whether the primitive unit cell .cif files should be used instead of ground-state structure .cif files. Setting to \code{True} will reduce job time but may yield inaccurate results. \\ \hline

\code{--pseudo\_pot} & \code{-ps} & \code{str} & \code{"C19"} & any one of \code{C19}, \code{QC5}, or \code{"NCP19"} & Specifies the pseudopotential library that will be used during this run. Corresponds to the CASTEP \code{.cell} file keyword \code{SPECIES\_POT}. \\ \hline

\code{--queue} & \code{-q} & \code{int} & \code{10} & any $\geq 1$ & Specifies the maximum number of job arrays that will be submitted to the SLURM queue at a time. \\ \hline

\code{--reserve} & \code{-r} & \code{str} & \code{""} & any string & Specifies the reservation string used when submitting a job array to the SLURM queue. \\ \hline

\code{--save} & \code{-sa} & \code{bool} & \code{True} & any string that can be interpreted as a boolean & Specifies whether plots should be saved to \code{.png} files in the \code{./figs} directory, or drawn on screen. \\ \hline

\code{--max\_scf\_cycles} & \code{-sc} & \code{int} & \code{100} & any $\geq 1$ & Determines the maximum number of SCF cycles performed in an electronic minimisation. Corresponds to the CASTEP \code{.param} file keyword \code{MAX\_SCF\_CYCLES}. \\ \hline

\code{--stress} & \code{-st} & \code{bool} & \code{False} & any string that can be interpreted as a boolean & Controls whether or not a stress calculation will be performed. Setting to \code{True} will increase job time. \\ \hline

\code{--tasks} & \code{-t} & \code{int} & 20 & any $\geq 1$ & Specifies the number of SLURM tasks that a single job should use per node. \\ \hline

\code{--volume\_scale} & \code{-v} & \code{float} & \code{1.0} & any $> 0$ & Specifies the cell volume scale factor that will be applied on top of $\Delta$ project-relevant volume adjustments. \\ \hline

\end{tabularx}
\caption{Summary of optional arguments that can be passed to the \code{testgrids.py} (Part 2: [m-v])}
\label{tab:arguments2}
\end{table}

\clearpage

\begin{table}[!h]
\centering
\begin{tabularx}{1\linewidth}{|c|c|c|c|>{\hsize=1.2\hsize\linewidth=\hsize}Y|>{\hsize=0.8\hsize\linewidth=\hsize}Y|}
\hline
\textbf{Argument} & \textbf{Abbr.} & \textbf{Type} & \textbf{Default} & \textbf{Accepted values} & \textbf{Notes} \\ \hline

\code{--xc\_functional} & \code{-x} & \code{str} & \code{"PBE"} & any one of \code{"LDA"}, \code{"PW91"}, \code{"PBE"}, \code{"PBESOL"}, \code{"RPBE"}, \code{"WC"}, \code{"BLYP"}, \code{"LDA-C2"}, \code{"LDA-X"}, \code{"ZERO"}, \code{"HF"}, \code{"PBE0"}, \code{"B3LYP"}, \code{"HSE03"}, \code{"HSE06"}, \code{"EXX-X"}, \code{"HF-LDA"}, \code{"EXX"}, \code{"EXX-LDA"}, \code{"SHF"}, \code{"SX"}, \code{"SHF-LDA"}, \code{"SX-LDA"}, \code{"WDA"}, \code{"SEX"} or \code{"SEX-LDA"} & Controls which functional is used to calculate the exchange-correlation potential. Corresponds to the CASTEP \code{.param} file keyword \code{XC\_FUNCTIONAL}. \\ \hline

\end{tabularx}
\caption{Summary of optional arguments that can be passed to the \code{testgrids.py} (Part 3: [x])}
\label{tab:arguments3}
\end{table}

\subsection{Troubleshooting}

Although care has been taken to select a set of default parameters that minimise the rate of errors that can occur during the execution of the code, some errors with specific combinations of elements and corresponding parameters still remain. This section summarises all the possible ways in which code can fail; this includes non-critical errors (runtime errors in the SLURM queue, CASTEP jobs or EOS fitting function) as well as critical errors (often missing modules, permission issues, missing files, misspelled paths, or low disk space), and how to remedy them.

\begin{table}[h]
\begin{tabularx}{1\linewidth}{|>{\hsize=0.6\hsize\linewidth=\hsize}Y|c|>{\hsize=1.4\hsize\linewidth=\hsize}Y|}
\hline \hline
\textbf{Error message} & \textbf{Level} & \textbf{Notes} \\ \hline
\code{[WARNING] found .err file} \code{in dir ...} & NCE & This non-critical error is reported when the presence of an \code{.err} file is detected in any temporary job directory. The file is created by CASTEP when it encounters a runtime error such as a convergence failure or a non-variational total energy, and the contents of file should provide enough information regarding the error and how to remedy it. The presence of this error also means that a $\Delta$ value will not be calculated for that corresponding \code{FINE\_GRID\_SIZE} value of the element. \\ \hline
\code{[WARNING] job ... has} \code{encountered an error or} \code{been killed} & NCE & This non-critical error is reported when the presence the words ``error" or ``killed" is detected in an \code{.out} file. The error is reported by SLURM when a job exits with a non-zero return code (it failed in some way), or if the job has been killed (it requested more memory than is available, or exceeded the maximum allocated time); the contents of the file usually provides enough information regarding this error. The presence of this error also means that a $\Delta$ value will not be calculated for that corresponding \code{FINE\_GRID\_SIZE} value of the element. \\ \hline
\code{[WARNING] over 5 warnings} \code{detected in file ...} & W & This warning is reported when more than 5 occurrences of the word ``warning" are detected in the \code{.castep} file. Although some warnings during the first few steps of convergence are common, a large number of warnings may point to an issue that needs investigating. \\ \hline
\code{[DEBUG] discarded as EOS} \code{fitting function returned} \code{a complex or None type} \code{(not float)} & NCE & This non-critical error is reported when the Birch-Murnaghan EOS fitting function returns a complex number or \code{None} as a value for at least one EOS parameter. The error is a result of an inadequate or failed fit; inspecting the \code{name.table.txt} file to deduce whether the relevant E-V curve has a minimum, and adjusting parameters such as \code{--volume\_scale}, \code{--kpoint\_spacing}, \code{--elec\_enrg\_tol} or \code{--basis\_prec} should remedy this. The presence of this error also means that a $\Delta$ value will not be calculated for that corresponding \code{FINE\_GRID\_SIZE} value of the element. \\ \hline
\code{[DEBUG] discarded as EOS} \code{fitting function returned} \code{a negative bulk modulus} \code{derivative} & NCE & This non-critical error is simmilar to the previous one: it results from an inadequate fit, can be remedied in the same ways as the previous error, and also results in a $\Delta$ value being omitted. The difference between them is that this error is triggered when the EOS fitting function returns a negative bulk modulus derivative - an unphysical result.  \\ \hline \hline
\end{tabularx}
\caption{Summary of all possible non-critical errors and warnings, presented in order of the execution stage during which they can occur; [NCE] = Non-critical error, [W] = Warning}
\label{tab:my-table}
\end{table}

\begin{table}[h]
\begin{tabularx}{1\linewidth}{|c|>{\hsize=1\hsize\linewidth=\hsize}Y|>{\hsize=1\hsize\linewidth=\hsize}Y|}
\hline \hline
\textbf{Return code} & \textbf{Corresponding error} & \textbf{Notes} \\ \hline
\code{00} & None & Execution finished without encountering errors \\ \hline \hline
\code{01} & \code{ImportError} when importing modules & Check all required modules are installed \\ \hline
\code{02} & arg directory does not exist or is inaccessible & Check spelling and permissions of directory \\ \hline
\code{03} & arg file does not exist or is inaccessible & Check spelling and permission of file \\ \hline
\code{04} & \code{TypeError} when parsing args & Check the required arg types in Tables \ref{tab:arguments1}, \ref{tab:arguments2}, \ref{tab:arguments3} \\ \hline
\code{05} & arg out of bounds & Check the arg accepted values in Tables \ref{tab:arguments1}, \ref{tab:arguments2}, \ref{tab:arguments3} \\ \hline
\code{06} & arg not one of possible options & Check the arg accepted values in Tables \ref{tab:arguments1}, \ref{tab:arguments2}, \ref{tab:arguments3} \\ \hline
\code{07} & \code{CalledProcessError} when loading CASTEP & Use \code{--castep} for different CASTEP module \\ \hline \hline
\code{10} & \code{OSError} while generating job data & Check write permissions and remaining space \\ \hline
\code{11} & \code{CalledProcessError} while generating data & Verify that \code{cif2cell} is available in PATH \\ \hline
\code{19} & uncaught exception while generating job data & Inspect error message for more details \\ \hline \hline
\code{20} & \code{CalledProcessError} while running jobs & Verify that \code{sbatch} and \code{squeue} are available \\ \hline
\code{29} & uncaught exception while running jobs & Inspect error message for more details \\ \hline \hline
\code{30} & \code{OSError} while reading job output data & Check \code{testgrids.py} has read permissions \\ \hline
\code{31} & \code{PickleError} when saving array data to disk & Check write permissions and available space \\ \hline
\code{39} & uncaught exception while read job output data & Inspect error message for more details \\ \hline \hline
\code{40} & \code{OSError} while cleaning up & Check write permissions or close opened files \\ \hline
\code{49} & uncaught exception while cleaning up & Inspect error message for more details \\ \hline \hline
\code{50} & \code{OSError} while opening pickle file handle & Check read permissions and path spelling \\ \hline
\code{51} & \code{PickleError} when loading pickle data & Verify pickle file is valid and not corrupted \\ \hline
\code{59} & uncaught exception while loading data arrays & Inspect error message for more details \\ \hline \hline
\code{69} & uncaught exception while deleting semaphores & Inspect error message for more details \\ \hline \hline
\end{tabularx}
\caption{Summary of all possible critical errors. As all of these errors cease the execution of the script, the corresponding return codes are also provided.}
\label{tab:my-table}
\end{table}


% talk about all possible ways the simulation can fail. .err files, error in out, warnings, eos fit fail (complex, None, delta), no minimum can be foudn

% debug mode

\subsection{Overview of code}



%debugging section



% talk about _string2bool

% layout of code and notes, so people can follow it if they read it

% code usage etc, function descriptions

% talk about what happens when some arguments exceed recommended limits are selected

\subsection{Analysis of Output}

% graphs, talk about meaning, etc

%\section{}

%\newpage

%\begin{landscape}
%\include{S1_flowchart.tex}
%\end{landscape}